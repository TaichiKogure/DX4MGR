# D4M（DX4MGRフレームワーク）アプリ開発メモ

## 目的（初心者向けに一言で）
現実ログから「プロセス」を推定し、DES（待ち行列＋会議ゲート）と最小限のAgentで再現し、
同化（定期更新）で現実に追従させながら、What-if政策実験を比較できるシンプルなアプリを作る。  
※平均は使わず、P90/CCDF/WIP/ボトルネックを出す。

---

## 0. 最小完成形（まず“1枚のゴール”を決める）
**最小で完成したと言える状態**を先に固定します。
- CSVログを読み込む
- 推定パラメータを計算する
- DESを回す（待ち行列＋会議ゲート）
- P90 / CCDF / WIP / ボトルネックランキングを出す
- 1つだけ政策実験（例：会議頻度変更）を比較する

> これができれば「最初の価値が出た」と判断できる。

---

## 1. ログ（現実）→ 推定パラメータ
### 目的
シミュレーションに必要な数字をログから作る。

### 最初のログ例（CSV）
```
case_id,start_time,end_time,queue_type,handler,meeting_id
A001,2025-01-10 09:00,2025-01-10 10:30,dev,alice,M01
A002,2025-01-10 09:10,2025-01-10 11:40,dev,bob,M01
```

### 推定するもの（最小限）
- **到着率**（案件が来る頻度）
- **処理時間分布**（作業時間のばらつき）
- **会議待ち時間／会議頻度**

### 初学者向けポイント
- 最初は **P50 / P90** の分位点だけでもOK。
- まず「分布がある」と理解して、平均は使わない。

---

## 2. DES（待ち行列＋会議ゲート）
### 目的
ログで得たパラメータから「流れ」を再現する。

### 最小の構成
- **到着** → **待ち** → **処理**
- **会議ゲート**：一定時間ごとに「まとめて進む」

### 初学者向けポイント
- まずは工程1つでOK。
- 会議ゲートは「時間窓で一斉に進む」だけでも十分。

---

## 3. 必要最小限のAgentで“組織の癖”を出す
### 目的
平均的な流れでは出ない、現実っぽい偏りを再現。

### 最小Agent例
- **高スキル担当**（処理が早い）
- **低スキル担当**（処理が遅い）
- **調整役**（会議頻度に影響）

### 初学者向けポイント
- 2〜3種類に絞る。
- まずは「処理時間に差がある」だけで十分。

---

## 4. 同化（定期更新）
### 目的
モデルのズレを定期的に現実へ戻す。

### 最小の回し方
1. 週次 or 月次でログ再取得
2. パラメータを再推定
3. DESを再実行

---

## 5. 政策実験（What-if）
### 目的
施策の効果を比較する。

### 最小実験セット
- 会議頻度を増やす／減らす
- 会議の定員数を変更
- 調整役を1人追加

---

## 6. 出力（平均禁止）
### 必須出力
- **P90**（遅い尾っぽを見る）
- **CCDF**（遅延案件の割合）
- **WIP**（仕掛かり量）
- **ボトルネックランキング**

---

## 7. 最小フォルダ構成（フレーム）
```
/data        # ログCSV
/src
  estimator/ # 推定処理
  des/       # シミュレーション
  agent/     # Agent定義
  report/    # P90/CCDF/WIP出力
  scenario/  # What-if設定
```

---

## 8. （参考）Windows本体PCから外部装置を制御する想定
> ※将来、外部装置（例：ラズパイ）を使う場合の最小メモ。

- **Windows PC**：UI / レポート / 分析
- **外部装置**：ログ収集 or シミュレーション実行
- **通信方法**：SSH / SCP / API

※今回のスコープでは「シンプルにローカルシミュレーション」でも可。

---

## まとめ（最初の一歩）
1. **CSVログを1本作る**
2. **P90を出すだけの小さなスクリプトを書く**
3. **待ち行列＋会議ゲートのDESを回す**
4. **Agentを2種類だけ追加**
5. **会議頻度を変えて比較**

この順で進めると、初心者でも確実に前に進める。
